/* (c) 2025 Open Source Geospatial Foundation - all rights reserved
 * This code is licensed under the GPL 2.0 license, available at the root
 * application directory.
 */
package org.geoserver.web.security.oauth2.intgration.keycloak;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import jakarta.servlet.ServletRequestEvent;
import jakarta.servlet.http.HttpSession;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.hc.core5.http.NameValuePair;
import org.apache.hc.core5.net.URIBuilder;
import org.geoserver.data.test.SystemTestData;
import org.geoserver.platform.GeoServerExtensions;
import org.geoserver.security.GeoServerSecurityFilterChain;
import org.geoserver.security.GeoServerSecurityFilterChainProxy;
import org.geoserver.security.GeoServerSecurityManager;
import org.geoserver.security.RequestFilterChain;
import org.geoserver.security.config.SecurityManagerConfig;
import org.geoserver.security.oauth2.login.GeoServerOAuth2LoginAuthenticationFilter;
import org.geoserver.security.oauth2.login.GeoServerOAuth2LoginFilterConfig;
import org.geoserver.web.GeoServerHomePage;
import org.junit.BeforeClass;
import org.junit.Test;
import org.springframework.mock.web.MockFilterChain;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.oauth2.client.authentication.OAuth2AuthenticationToken;
import org.springframework.security.oauth2.core.oidc.user.DefaultOidcUser;
import org.springframework.security.web.context.HttpSessionSecurityContextRepository;
import org.springframework.web.context.request.RequestContextListener;

/**
 * Basic login is as follows:
 *
 * <p>1. Get the GS homepage (via wicket) <br>
 * 2. There should be a button/anchor that sends the user to "/web/oauth2/authorization/oidc" <br>
 * 3. Click the button <br>
 * 4. Response should be a redirect to keycloak <br>
 * * verify the URL's params <br>
 * * remember the `nonce` and `state` params (these are pre-login generated by spring) <br>
 * 5. send the request to the keycloak container <br>
 * 6. Keycloak will respond with a login form <br>
 * * from the response, extract the form's {@code <form action=....> URL} <br>
 * * this will have a bunch of keycloak-specific parameters <br>
 * * capture the cookies keycloak sets <br>
 * 7. submit a POST request to keycloak <br>
 * * use the form's `action=....` (with a bunch of parms) as the URL <br>
 * * In the body, put `username=admin&password=admin&credentialId=` (for user admin, password admin) <br>
 * * set `Content-Type` to `application/x-www-form-urlencoded` <br>
 * * attach keycloak's cookies <br>
 * 8. The response will be a redirect to GeoServer (code request) <br>
 * * will be to `http://localhost:8080/geoserver/web/login/oauth2/code/oidc` <br>
 * * will have a bunch of params (including `code`) <br>
 * 9. Execute, in GS, the redirect URL <br>
 * 10. Extract the security context (from mock GS) <br>
 * 11. Validate the info in the security context <br>
 * NOTE: all GS requests should use the same session
 *
 * <p>This is executing a login in a manner VERY similar to how a user would on the browser. See
 * `executeOnSecurityFilters()` - this is how we emulate a non-wicket request.
 *
 * <p>Please see the README.md in the `resources/org/geoserver/web/security/oauth2/intgration/keycloak` directory for
 * more information on how to change the keycloak configuration.
 */
public class KeyCloakIntegrationTest extends KeyCloakIntegrationTestSupport {

    // these are what's expected in the GS->OIDC IDP redirect URL
    String oidcLogin_responseType = "code";
    String oidcLogin_client_id = "gs-client";
    String oidcLogin_scope = "openid profile email phone address";
    String oidcLogin_redirect_uri = "http://localhost:8080/geoserver/web/login/oauth2/code/oidc";

    /**
     * Configure GS logging level.
     *
     * @return logging level
     */
    @Override
    protected String getLogConfiguration() {
        return "VERBOSE_LOGGING";
    }

    @BeforeClass
    public static void beforeClassLocal() {
        // for test cases this needs to be set by the OIDC module so it knows the mock server's base URL
        System.setProperty("OPENID_TEST_GS_PROXY_BASE", "http://localhost/geoserver");
    }

    /**
     * Login as admin/admin.
     *
     * @throws Exception error occurred
     */
    @Test
    public void test_login_as_admin() throws Exception {
        OAuth2AuthenticationToken auth = login("admin", "admin");

        // validate the security context (auth)
        assertTrue(auth.isAuthenticated());
        assertEquals("oidc", auth.getAuthorizedClientRegistrationId());

        assertEquals("admin@example.com", auth.getPrincipal().getName());
        assertEquals("admin@example.com", auth.getName());

        assertEquals(2, auth.getAuthorities().size());
        assertEquals(2, auth.getPrincipal().getAuthorities().size());
        assertTrue(auth.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .toList()
                .contains("ROLE_AUTHENTICATED"));
        assertTrue(auth.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .toList()
                .contains("ROLE_ADMINISTRATOR"));

        assertEquals("admin", auth.getPrincipal().getAttributes().get("preferred_username"));
        assertEquals("gs-client", auth.getPrincipal().getAttributes().get("azp"));
        assertEquals("admin", auth.getPrincipal().getAttributes().get("family_name"));
        assertEquals("admin admin", auth.getPrincipal().getAttributes().get("name"));

        // get IDTOKEN.resource_access.gs-client.roles
        // this should be "geoserverAdmin" (from keycloak)
        DefaultOidcUser principal = (DefaultOidcUser) auth.getPrincipal();
        @SuppressWarnings("rawtypes")
        Map resourceAccess = (Map) principal.getIdToken().getClaim("resource_access");
        assertNotNull(resourceAccess);
        @SuppressWarnings("rawtypes")
        Map gsClient = (Map) resourceAccess.get("gs-client");
        assertNotNull(gsClient);
        @SuppressWarnings("rawtypes")
        List gsClientRoles = (List) gsClient.get("roles");
        assertEquals("geoserverAdmin", gsClientRoles.get(0));
    }

    /**
     * Login as user_sample1/user_sample1.
     *
     * @throws Exception error occurred
     */
    @Test
    public void test_login_as_user_sample1() throws Exception {
        OAuth2AuthenticationToken auth = login("user_sample1", "user_sample1");

        // validate the security context (auth)
        assertTrue(auth.isAuthenticated());
        assertEquals("oidc", auth.getAuthorizedClientRegistrationId());

        assertEquals("user_sample1@example.com", auth.getPrincipal().getName());
        assertEquals("user_sample1@example.com", auth.getName());

        assertEquals(1, auth.getAuthorities().size());
        assertEquals(1, auth.getPrincipal().getAuthorities().size());
        assertTrue(auth.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .toList()
                .contains("ROLE_AUTHENTICATED"));

        assertEquals("user_sample1", auth.getPrincipal().getAttributes().get("preferred_username"));
        assertEquals("gs-client", auth.getPrincipal().getAttributes().get("azp"));
        assertEquals("sample1", auth.getPrincipal().getAttributes().get("family_name"));
    }

    /**
     * does the actual login (see top-of-class comments for details).
     *
     * @param keycloakUserName username in keycloak (i.e. admin)
     * @param keycloakPassword password in keycloak (i.e. admin)
     * @return authentication (from GS security context)
     * @throws Exception error occurred
     */
    public OAuth2AuthenticationToken login(String keycloakUserName, String keycloakPassword) throws Exception {
        tester.startPage(new GeoServerHomePage());
        String html = tester.getLastResponseAsString();

        // 1. verify that there's a login button for oidc
        assertTrue(html.contains(
                "<a class=\"d-inline-block\" href=\"http://localhost/context/web/oauth2/authorization/oidc\">"));

        // 2. lets "press" the oidc login link:
        MockHttpServletRequest webRequest = createRequest("web/oauth2/authorization/oidc", true);
        MockHttpServletResponse webResponse = executeOnSecurityFilters(webRequest);
        HttpSession session = webRequest.getSession();

        // should be a 302 redirect to keycloak to start the login process
        Pair<String, String> state_nonce = validateRedirectToKeyCloak(webResponse);
        String oidcLogin_state = state_nonce.getLeft();
        String oidcLogin_nonce = state_nonce.getRight();

        return keycloakLogin(session, oidcLogin_state, oidcLogin_nonce, keycloakUserName, keycloakPassword);
    }

    /**
     * validates the GS -> OIDC IDP URL and returns the state and nonce.
     *
     * @param webResponse response from GS
     * @return .left is state, .right is nonce
     * @throws URISyntaxException error occurred (most likely misconfigured)
     */
    private Pair<String, String> validateRedirectToKeyCloak(MockHttpServletResponse webResponse)
            throws URISyntaxException {
        // should be a 302 redirect to keycloak to start the login process
        assertEquals(302, webResponse.getStatus());
        assertNotNull(webResponse.getHeader("Location"));
        String redirectURL = webResponse.getHeader("Location");

        assertTrue(redirectURL.startsWith(authServerUrl));

        List<NameValuePair> params = new URIBuilder(new URI(redirectURL), StandardCharsets.UTF_8).getQueryParams();

        assertEquals(
                oidcLogin_responseType,
                params.stream()
                        .filter(x -> x.getName().equals("response_type"))
                        .findFirst()
                        .get()
                        .getValue());
        assertEquals(
                oidcLogin_client_id,
                params.stream()
                        .filter(x -> x.getName().equals("client_id"))
                        .findFirst()
                        .get()
                        .getValue());
        assertEquals(
                oidcLogin_redirect_uri,
                params.stream()
                        .filter(x -> x.getName().equals("redirect_uri"))
                        .findFirst()
                        .get()
                        .getValue());
        assertEquals(
                oidcLogin_scope,
                params.stream()
                        .filter(x -> x.getName().equals("scope"))
                        .findFirst()
                        .get()
                        .getValue());

        String oidcLogin_state = params.stream()
                .filter(x -> x.getName().equals("state"))
                .findFirst()
                .get()
                .getValue();
        String oidcLogin_nonce = params.stream()
                .filter(x -> x.getName().equals("nonce"))
                .findFirst()
                .get()
                .getValue();

        return new ImmutablePair<>(oidcLogin_state, oidcLogin_nonce);
    }

    /**
     * Given the info from the GS -> OIDC IDP redirect, do the actual keycloak login and GS login.
     *
     * @param session GS session must be the same for all requests
     * @param oidcLoginState state (generated by GS for the login)
     * @param oidcLoginNonce nonce (generated by GS for the login)
     * @param username who to login to keycloak as
     * @param password keycloak's user's password
     * @return GS security context auth
     * @throws Exception error occurred
     */
    private OAuth2AuthenticationToken keycloakLogin(
            HttpSession session, String oidcLoginState, String oidcLoginNonce, String username, String password)
            throws Exception {
        // send request to keycloak to start the login process (will return with username/password form)
        WebRequests.WebResponse startKeyCloakResponse = executeKeycloakStartUrl(oidcLoginState, oidcLoginNonce);
        assertEquals(200, startKeyCloakResponse.statusCode);

        // send keycloak the completed username/password form
        WebRequests.WebResponse keycloakResponseSubmitUserPassword =
                executeKeycloakResponseSubmitUserPassword(startKeyCloakResponse, username, password);
        assertEquals(302, keycloakResponseSubmitUserPassword.statusCode);
        String redirectCodeToGS =
                keycloakResponseSubmitUserPassword.headers.get("Location").get(0);
        // should be redirecting to GS's code endpoint
        assertTrue(redirectCodeToGS.startsWith("http://localhost:8080/geoserver/web/login/oauth2/code/oidc"));

        String shortenedRedirectCodeToGS = redirectCodeToGS.substring("http://localhost:8080/geoserver/".length());
        MockHttpServletRequest webRequest = createRequest(shortenedRedirectCodeToGS);
        webRequest.setSession(session);
        // execute on security filters (response result is unused)
        executeOnSecurityFilters(webRequest);

        // get security context (Spring Security 6 style)
        HttpSessionSecurityContextRepository repo = new HttpSessionSecurityContextRepository();
        SecurityContext securityContext = repo.loadDeferredContext(webRequest).get(); // lazily resolves from session

        assertNotNull(securityContext);
        assertNotNull(securityContext.getAuthentication());
        assertTrue(securityContext.getAuthentication() instanceof OAuth2AuthenticationToken);

        return (OAuth2AuthenticationToken) securityContext.getAuthentication();
    }

    /**
     * keycloak's username/password form has an action with "extra" params in it - submit
     *
     * @param startKeyCloakResponse GS's redirect to keycloak to start login
     * @param username keycloak's username
     * @param password keycloak's user's password
     * @return response from keycloak's form submit
     * @throws Exception error occurred
     */
    public WebRequests.WebResponse executeKeycloakResponseSubmitUserPassword(
            WebRequests.WebResponse startKeyCloakResponse, String username, String password) throws Exception {
        Pattern pattern = Pattern.compile(".* action=\"([^\"]+)\".*", Pattern.DOTALL);
        Matcher matcher = pattern.matcher(startKeyCloakResponse.body);
        if (!matcher.matches()) {
            throw new Exception("keycloak - couldnt find the login form's action url");
        }
        String postUrl = matcher.group(1).replaceAll("&amp;", "&");
        String postBody = "username=" + username + "&password=" + password + "&credentialId=";
        return WebRequests.webRequestPOSTForm(postUrl, postBody, startKeyCloakResponse.cookieManager);
    }

    /**
     * Start the keycloak login process
     *
     * @param oidcLoginState state (generated by GS for the login)
     * @param oidcLoginNonce nonce (generated by GS for the login)
     * @return response from keycloak (i.e. the login form)
     * @throws Exception error occurred
     */
    public WebRequests.WebResponse executeKeycloakStartUrl(String oidcLoginState, String oidcLoginNonce)
            throws Exception {
        String startUrl = authServerUrl + "/realms/gs-realm/protocol/openid-connect/auth?";
        startUrl += "client_id=" + oidcLogin_client_id;
        startUrl += "&response_type=" + oidcLogin_responseType;
        startUrl += "&scope=" + URLEncoder.encode(oidcLogin_scope, StandardCharsets.UTF_8);
        startUrl += "&redirect_uri=" + oidcLogin_redirect_uri;
        startUrl += "&state=" + oidcLoginState;
        startUrl += "&nonce=" + oidcLoginNonce;
        return WebRequests.webRequestGET(startUrl);
    }

    /**
     * taken from another integration test. Execute a web request on the security filters (i.e. oidc filters) in GS.
     *
     * @param request request to execute
     * @return response from GS
     * @throws IOException error occurred
     * @throws jakarta.servlet.ServletException error occurred
     */
    private MockHttpServletResponse executeOnSecurityFilters(MockHttpServletRequest request)
            throws IOException, jakarta.servlet.ServletException {
        // for session local support in Spring
        new RequestContextListener().requestInitialized(new ServletRequestEvent(request.getServletContext(), request));

        MockFilterChain chain = new MockFilterChain();
        MockHttpServletResponse response = new MockHttpServletResponse();
        GeoServerSecurityFilterChainProxy filterChainProxy =
                GeoServerExtensions.bean(GeoServerSecurityFilterChainProxy.class);
        filterChainProxy.doFilter(request, response, chain);

        return response;
    }

    /**
     * setup GS with an oidc filter that points to our testcontainer's keycloak.
     *
     * @param testData GS config
     * @throws Exception error occurred
     */
    @Override
    protected void onSetUp(SystemTestData testData) throws Exception {
        super.onSetUp(testData);

        String baseKeycloakUrl = keycloakContainer.getAuthServerUrl() + "/realms/gs-realm/protocol/openid-connect";
        // setup openid
        GeoServerSecurityManager manager = getSecurityManager();
        GeoServerOAuth2LoginFilterConfig filterConfig = new GeoServerOAuth2LoginFilterConfig();
        filterConfig.setName("openidconnect");
        filterConfig.setClassName(GeoServerOAuth2LoginAuthenticationFilter.class.getName());
        filterConfig.setOidcEnabled(true);
        filterConfig.setOidcClientId(oidcClient);
        filterConfig.setOidcClientSecret(oidcClientSecret);
        filterConfig.setBaseRedirectUri("http://localhost:8080/geoserver/");
        filterConfig.calculateRedirectUris();
        filterConfig.setOidcTokenUri(baseKeycloakUrl + "/token");
        filterConfig.setOidcAuthorizationUri(baseKeycloakUrl + "/authorize");
        filterConfig.setOidcUserInfoUri(baseKeycloakUrl + "/userinfo");
        filterConfig.setOidcLogoutUri(baseKeycloakUrl + "/endSession");
        filterConfig.setOidcJwkSetUri(baseKeycloakUrl + "/certs");
        filterConfig.setOidcEnforceTokenValidation(false);
        filterConfig.setOidcScopes("openid profile email phone address");
        filterConfig.setEnableRedirectAuthenticationEntryPoint(false);
        filterConfig.setOidcUserNameAttribute("email");
        filterConfig.setRoleSource(GeoServerOAuth2LoginFilterConfig.OpenIdRoleSource.IdToken);
        filterConfig.setTokenRolesClaim("roles");

        // setup roles extraction
        filterConfig.setRoleSource(GeoServerOAuth2LoginFilterConfig.OpenIdRoleSource.IdToken);
        filterConfig.setRoleConverterString("geoserverAdmin=ROLE_ADMINISTRATOR");
        filterConfig.setOnlyExternalListedRoles(true);
        filterConfig.setTokenRolesClaim("resource_access.gs-client.roles");

        filterConfig.setOidcForceAuthorizationUriHttps(false);
        filterConfig.setOidcForceTokenUriHttps(false);
        // filterConfig.setOidcJwsAlgorithmName(JwsAlgorithms.HS256);
        manager.saveFilter(filterConfig);

        // add our oidc to the WEB chain
        SecurityManagerConfig config = manager.getSecurityConfig();
        GeoServerSecurityFilterChain chain = config.getFilterChain();
        RequestFilterChain www = chain.getRequestChainByName("web");
        www.setFilterNames("openidconnect", "anonymous");

        manager.saveSecurityConfig(config);
    }
}
