{"version":3,"file":"map-feature.js","sources":["../src/map-feature.js"],"sourcesContent":["export class MapFeature extends HTMLElement {\n  static get observedAttributes() {\n    return ['zoom', 'min', 'max'];\n  }\n\n  get zoom() {\n    return +(this.hasAttribute('zoom') ? this.getAttribute('zoom') : 0);\n  }\n\n  set zoom(val) {\n    var parsedVal = parseInt(val, 10);\n    if (!isNaN(parsedVal) && parsedVal >= this.min && parsedVal <= this.max) {\n      this.setAttribute('zoom', parsedVal);\n    }\n  }\n\n  get min() {\n    // fallback: the minimum zoom bound of layer- element\n    return +(this.hasAttribute('min')\n      ? this.getAttribute('min')\n      : this._layer._layerEl.extent.zoom.minZoom);\n  }\n\n  set min(val) {\n    var parsedVal = parseInt(val, 10);\n    if (!isNaN(parsedVal)) {\n      if (\n        parsedVal >= this._layer._layerEl.extent.zoom.minZoom &&\n        parsedVal <= this._layer._layerEl.extent.zoom.maxZoom\n      ) {\n        this.setAttribute('min', parsedVal);\n      } else {\n        this.setAttribute('min', this._layer._layerEl.extent.zoom.minZoom);\n      }\n    }\n  }\n\n  get max() {\n    // fallback: the maximum zoom bound of layer- element\n    return +(this.hasAttribute('max')\n      ? this.getAttribute('max')\n      : this._layer._layerEl.extent.zoom.maxZoom);\n  }\n\n  set max(val) {\n    var parsedVal = parseInt(val, 10);\n    if (!isNaN(parsedVal)) {\n      if (\n        parsedVal >= this._layer._layerEl.extent.zoom.minZoom &&\n        parsedVal <= this._layer._layerEl.extent.zoom.maxZoom\n      ) {\n        this.setAttribute('max', parsedVal);\n      } else {\n        this.setAttribute('max', this._layer._layerEl.extent.zoom.maxZoom);\n      }\n    }\n  }\n\n  get extent() {\n    if (this.isConnected) {\n      // if the feature extent is the first time to be calculated or the feature extent is changed (by changing\n      // the innertext of map-coordinates), then calculate feature extent by invoking the getFeatureExtent function\n      if (!this._getFeatureExtent) {\n        this._getFeatureExtent = this._memoizeExtent();\n      }\n      return this._getFeatureExtent();\n    }\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    switch (name) {\n      case 'zoom': {\n        if (oldValue !== newValue && this._layer) {\n          let layer = this._layer,\n            zoom = newValue,\n            mapmlvectors = layer._mapmlvectors;\n          // if the vector layer only has static features, should update zoom bounds when zoom attribute is changed\n          if (mapmlvectors._staticFeature) {\n            this._removeInFeatureList(oldValue);\n            if (zoom in mapmlvectors._features) {\n              mapmlvectors._features[zoom].push(this._featureGroup);\n            } else {\n              mapmlvectors._features[zoom] = [this._featureGroup];\n            }\n            let native = this._getNativeZoomAndCS(layer._content);\n            mapmlvectors.zoomBounds = M.getZoomBounds(\n              layer._content,\n              native.zoom\n            );\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n\n  connectedCallback() {\n    // if mapFeature element is not connected to layer- or layer-'s shadowroot,\n    // or the parent layer- element has a \"data-moving\" attribute\n    if (\n      (this.parentNode.nodeType !== document.DOCUMENT_FRAGMENT_NODE &&\n        this.parentNode.nodeName.toLowerCase() !== 'layer-') ||\n      (this.parentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE &&\n        this.parentNode.host.hasAttribute('data-moving')) ||\n      (this.parentNode.nodeName.toLowerCase() === 'layer-' &&\n        this.parentNode.hasAttribute('data-moving'))\n    ) {\n      return;\n    }\n    // set up the map-feature object properties\n    this._addFeature();\n    // use observer to monitor the changes in mapFeature's subtree\n    // (i.e. map-properties, map-featurecaption, map-coordinates)\n    this._observer = new MutationObserver((mutationList) => {\n      for (let mutation of mutationList) {\n        // the attributes changes of <map-feature> element should be handled by attributeChangedCallback()\n        if (mutation.type === 'attributes' && mutation.target === this) {\n          return;\n        }\n        // re-render feature if there is any observed change\n        this._reRender();\n      }\n    });\n    this._observer.observe(this, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeOldValue: true,\n      characterData: true\n    });\n  }\n\n  disconnectedCallback() {\n    if (!this._layer) return;\n    if (this._layer._layerEl.hasAttribute('data-moving')) return;\n    this._removeFeature();\n    this._observer.disconnect();\n  }\n\n  _reRender() {\n    if (this._groupEl.isConnected) {\n      let native = this._getNativeZoomAndCS(this._layer._content);\n      let placeholder = document.createElement('span');\n      this._groupEl.insertAdjacentElement('beforebegin', placeholder);\n\n      this._featureGroup._map.removeLayer(this._featureGroup);\n      // Garbage collection needed\n      this._featureGroup = this._layer._mapmlvectors\n        .addData(this, native.cs, native.zoom)\n        .addTo(this._map);\n      placeholder.replaceWith(this._featureGroup.options.group);\n      // TODO: getBounds() should dynamically update the layerBounds and zoomBounds\n      this._layer._setLayerElExtent();\n      delete this._getFeatureExtent;\n      this._setUpEvents();\n    }\n  }\n\n  _removeFeature() {\n    // if the <layer- > el is disconnected\n    // the <g> el has already got removed at this point\n    if (this._groupEl?.isConnected) {\n      this._groupEl.remove();\n    }\n    // if the <layer- > el has already been disconnected,\n    // then _map.removeLayer(layerEl._layer) has already been invoked (inside layerEl.disconnectedCallback())\n    // this._featureGroup has already got removed at this point\n    if (this._featureGroup?._map) {\n      this._featureGroup._map.removeLayer(this._featureGroup);\n      let mapmlvectors = this._layer._mapmlvectors;\n      if (mapmlvectors) {\n        if (mapmlvectors._staticFeature) {\n          if (mapmlvectors._features[this.zoom]) {\n            this._removeInFeatureList(this.zoom);\n          }\n          let container = this._layer.shadowRoot || this._layer._layerEl;\n          // update zoom bounds of vector layer\n          mapmlvectors.zoomBounds = M.getZoomBounds(\n            this._layer._content,\n            this._getNativeZoomAndCS(this._layer._content).zoom\n          );\n        }\n        mapmlvectors.options.properties = null;\n        delete mapmlvectors._layers[this._featureGroup._leaflet_id];\n      }\n    }\n    delete this._featureGroup;\n    delete this._groupEl;\n    // ensure that feature extent can be re-calculated everytime that map-feature element is updated / re-added\n    if (this._getFeatureExtent) delete this._getFeatureExtent;\n  }\n\n  _addFeature() {\n    this._parentEl =\n      this.parentNode.nodeName.toUpperCase() === 'LAYER-' ||\n      this.parentNode.nodeName.toUpperCase() === 'MAP-EXTENT'\n        ? this.parentNode\n        : this.parentNode.host;\n\n    this._parentEl.whenReady().then(() => {\n      let parentLayer =\n        this._parentEl.nodeName.toUpperCase() === 'LAYER-'\n          ? this._parentEl\n          : this._parentEl.parentElement || this._parentEl.parentNode.host;\n      this._layer = parentLayer._layer;\n      this._map = this._layer._map;\n      let mapmlvectors = this._layer._mapmlvectors;\n      // \"synchronize\" the event handlers between map-feature and <g>\n      if (!this.querySelector('map-geometry')) return;\n      if (!this._extentEl) {\n        let native = this._getNativeZoomAndCS(this._layer._content);\n        this._featureGroup = mapmlvectors.addData(this, native.cs, native.zoom);\n        if (parentLayer.checked) {\n          this._featureGroup.addTo(this._map);\n        }\n        mapmlvectors._layers[this._featureGroup._leaflet_id] =\n          this._featureGroup;\n        if (mapmlvectors._staticFeature && !this._extentEl) {\n          // update zoom bounds of vector layer\n          mapmlvectors.zoomBounds = M.getZoomBounds(\n            this._layer._content,\n            this._getNativeZoomAndCS(this._layer._content).zoom\n          );\n          // todo: dynamically update layer bounds of vector layer\n          mapmlvectors.layerBounds = M.getBounds(this._layer._content);\n          // update map's zoom limit\n          this._map._addZoomLimit(mapmlvectors);\n          // TODO: can be set as a handler of featureLayer\n          mapmlvectors._resetFeatures();\n          L.extend(mapmlvectors.options, mapmlvectors.zoomBounds);\n        }\n      }\n\n      if (Object.keys(mapmlvectors._layers).length === 1) {\n        this._layer._setLayerElExtent();\n      }\n      this._setUpEvents();\n    });\n  }\n\n  _setUpEvents() {\n    ['click', 'focus', 'blur', 'keyup', 'keydown'].forEach((name) => {\n      // when <g> is clicked / focused / blurred\n      // should dispatch the click / focus / blur event listener on **linked HTMLFeatureElements**\n      this._groupEl.addEventListener(name, (e) => {\n        if (name === 'click') {\n          // dispatch a cloned mouseevent to trigger the click event handlers set on HTMLFeatureElement\n          let clickEv = new PointerEvent(name, { cancelable: true });\n          clickEv.originalEvent = e;\n          this.dispatchEvent(clickEv);\n        } else if (name === 'keyup' || name === 'keydown') {\n          let keyEv = new KeyboardEvent(name, { cancelable: true });\n          keyEv.originalEvent = e;\n          this.dispatchEvent(keyEv);\n        } else {\n          // dispatch a cloned focusevent to trigger the focus/blue event handlers set on HTMLFeatureElement\n          let focusEv = new FocusEvent(name, { cancelable: true });\n          focusEv.originalEvent = e;\n          this.dispatchEvent(focusEv);\n        }\n      });\n    });\n  }\n\n  _getNativeZoomAndCS(content) {\n    // content: referred to <layer- > if the <layer- > has inline <map-extent>, <map-feature> or <map-tile>\n    //          referred to remote mapml if the <layer- > has a src attribute, and the fetched mapml contains <map-feature>\n    //          referred to [map-meta, ...] if it is query\n    //          referred to null otherwise (i.e. <layer- > has fetched <map-extent> in shadow, the <map-feature> attaches to <map-extent>'s shadow)\n    let nativeZoom, nativeCS;\n    if (this._extentEl) {\n      // feature attaches to extent's shadow\n      if (this._extentEl.querySelector('map-link[rel=query]')) {\n        // for query, fallback zoom is the current map zoom level that the query is returned\n        let metaZoom, metaCS;\n        if (content) {\n          metaZoom = M._metaContentToObject(\n            Array.prototype.filter\n              .call(content, function (elem) {\n                return elem.matches('map-meta[name=zoom]');\n              })[0]\n              ?.getAttribute('content')\n          ).content;\n          metaCS = M._metaContentToObject(\n            Array.prototype.filter\n              .call(content, function (elem) {\n                return elem.matches('map-meta[name=cs]');\n              })[0]\n              ?.getAttribute('content')\n          ).content;\n        }\n        nativeZoom = metaZoom || this._map.getZoom();\n        nativeCS = metaCS || 'gcrs';\n      } else if (this._extentEl.querySelector('map-link[rel=features]')) {\n        // for templated feature, read fallback from the fetched mapml's map-meta[name=zoom / cs]\n        nativeZoom = this._extentEl._nativeZoom;\n        nativeCS = this._extentEl._nativeCS;\n      }\n      return { zoom: nativeZoom, cs: nativeCS };\n    } else {\n      // feature attaches to layer- or layer-'s shadow\n      if (content.nodeType === Node.DOCUMENT_NODE) {\n        // for features migrated from mapml, read native zoom and cs from the remote mapml\n        return M.getNativeVariables(content);\n      } else if (content.nodeName.toUpperCase() === 'LAYER-') {\n        // for inline features, read native zoom and cs from inline map-meta\n        let zoomMeta = this._parentEl.querySelectorAll('map-meta[name=zoom]'),\n          zoomLength = zoomMeta?.length;\n        nativeZoom = zoomLength\n          ? +zoomMeta[zoomLength - 1]\n              .getAttribute('content')\n              ?.split(',')\n              .find((str) => str.includes('value'))\n              ?.split('=')[1]\n          : 0;\n\n        let csMeta = this._parentEl.querySelectorAll('map-meta[name=cs]'),\n          csLength = csMeta?.length;\n        nativeCS = csLength\n          ? csMeta[csLength - 1].getAttribute('content')\n          : 'gcrs';\n        return { zoom: nativeZoom, cs: nativeCS };\n      }\n    }\n  }\n\n  // Util functions:\n  // internal method to calculate the extent of the feature and store it in cache for the first time\n  // and return cache when feature's extent is repeatedly requested\n  // for .extent\n  _memoizeExtent() {\n    // memoize calculated extent\n    let extentCache;\n    return function () {\n      if (extentCache && this._getFeatureExtent) {\n        // if the extent has already been calculated and is not updated, return stored extent\n        return extentCache;\n      } else {\n        // calculate feature extent\n        let map = this._map,\n          geometry = this.querySelector('map-geometry'),\n          native = this._getNativeZoomAndCS(\n            this._layer.queryMetas?.length\n              ? this._layer.queryMetas\n              : this._layer._content\n          ),\n          cs = geometry.getAttribute('cs') || native.cs,\n          // zoom level that the feature rendered at\n          zoom = this.zoom || native.zoom,\n          shapes = geometry.querySelectorAll(\n            'map-point, map-linestring, map-polygon, map-multipoint, map-multilinestring'\n          ),\n          bboxExtent = [\n            Infinity,\n            Infinity,\n            Number.NEGATIVE_INFINITY,\n            Number.NEGATIVE_INFINITY\n          ];\n        for (let shape of shapes) {\n          let coord = shape.querySelectorAll('map-coordinates');\n          for (let i = 0; i < coord.length; ++i) {\n            bboxExtent = _updateExtent(shape, coord[i], bboxExtent);\n          }\n        }\n        let topLeft = L.point(bboxExtent[0], bboxExtent[1]);\n        let bottomRight = L.point(bboxExtent[2], bboxExtent[3]);\n        let pcrsBound = M.boundsToPCRSBounds(\n          L.bounds(topLeft, bottomRight),\n          zoom,\n          map.options.projection,\n          cs\n        );\n        if (\n          shapes.length === 1 &&\n          shapes[0].tagName.toUpperCase() === 'MAP-POINT'\n        ) {\n          let projection = map.options.projection,\n            maxZoom = this.hasAttribute('max')\n              ? +this.getAttribute('max')\n              : M[projection].options.resolutions.length - 1,\n            tileCenter = M[projection].options.crs.tile.bounds.getCenter(),\n            pixel = M[projection].transformation.transform(\n              pcrsBound.min,\n              M[projection].scale(+this.zoom || maxZoom)\n            );\n          pcrsBound = M.pixelToPCRSBounds(\n            L.bounds(pixel.subtract(tileCenter), pixel.add(tileCenter)),\n            this.zoom || maxZoom,\n            projection\n          );\n        }\n        let result = Object.assign(\n          M._convertAndFormatPCRS(\n            pcrsBound,\n            map.options.crs,\n            map.options.projection\n          )\n        );\n        // memoize calculated result\n        extentCache = result;\n        return result;\n      }\n    };\n\n    // update the bboxExtent\n    function _updateExtent(shape, coord, bboxExtent) {\n      let data = coord.innerHTML\n        .trim()\n        .replace(/<[^>]+>/g, '')\n        .replace(/\\s+/g, ' ')\n        .split(/[<>\\ ]/g);\n      switch (shape.tagName) {\n        case 'MAP-POINT':\n          bboxExtent = M._updateExtent(bboxExtent, +data[0], +data[1]);\n          break;\n        case 'MAP-LINESTRING':\n        case 'MAP-POLYGON':\n        case 'MAP-MULTIPOINT':\n        case 'MAP-MULTILINESTRING':\n          for (let i = 0; i < data.length; i += 2) {\n            bboxExtent = M._updateExtent(bboxExtent, +data[i], +data[i + 1]);\n          }\n          break;\n        default:\n          break;\n      }\n      return bboxExtent;\n    }\n  }\n\n  // find and remove the feature from mapmlvectors._features if vector layer only contains static features, helper function\n  //      prevent it from being rendered again when zooming in / out (mapmlvectors.resetFeature() is invoked)\n  // TODO: Can be moved to FeatureLayer.js, pass in leaflet id for layer to remove\n  _removeInFeatureList(zoom) {\n    if (zoom === null) {\n      return;\n    }\n    let mapmlvectors = this._layer._mapmlvectors;\n    for (let i = 0; i < mapmlvectors._features[zoom].length; ++i) {\n      let feature = mapmlvectors._features[zoom][i];\n      if (feature._leaflet_id === this._featureGroup._leaflet_id) {\n        mapmlvectors._features[zoom].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  getMaxZoom() {\n    let tL = this.extent.topLeft.pcrs,\n      bR = this.extent.bottomRight.pcrs,\n      bound = L.bounds(\n        L.point(tL.horizontal, tL.vertical),\n        L.point(bR.horizontal, bR.vertical)\n      );\n    let projection = this._map.options.projection,\n      layerZoomBounds = this._layer._layerEl.extent.zoom,\n      minZoom = layerZoomBounds.minZoom ? layerZoomBounds.minZoom : 0,\n      maxZoom = layerZoomBounds.maxZoom\n        ? layerZoomBounds.maxZoom\n        : M[projection].options.resolutions.length - 1;\n    let newZoom;\n    if (this.hasAttribute('zoom')) {\n      // if there is a zoom attribute set to the map-feature, zoom to the zoom attribute value\n      newZoom = this.zoom;\n    } else {\n      // if not, calculate the maximum zoom level that can show the feature completely\n      newZoom = M.getMaxZoom(bound, this._map, minZoom, maxZoom);\n      if (this.max < newZoom) {\n        // if the calculated zoom is greater than the value of max zoom attribute, go with max zoom attribute\n        newZoom = this.max;\n      } else if (this.min > newZoom) {\n        // if the calculated zoom is less than the value of min zoom attribute, go with min zoom attribute\n        newZoom = this.min;\n      }\n    }\n    // prevent overzooming / underzooming\n    if (newZoom < minZoom) {\n      newZoom = minZoom;\n    } else if (newZoom > maxZoom) {\n      newZoom = maxZoom;\n    }\n\n    // should check whether the extent after zooming falls into the templated extent bound\n    return newZoom;\n  }\n\n  // internal support for returning a GeoJSON representation of <map-feature> geometry\n  // The options object can contain the following:\n  //      propertyFunction   - function(<map-properties>), A function that maps the features' <map-properties> element to a GeoJSON \"properties\" member.\n  //      transform          - Bool, Transform coordinates to gcrs values, defaults to True\n  // mapml2geojson: <map-feature> Object -> GeoJSON\n  mapml2geojson(options) {\n    let defaults = {\n      propertyFunction: null,\n      transform: true\n    };\n    // assign default values for undefined options\n    options = Object.assign({}, defaults, options);\n\n    let json = {\n      type: 'Feature',\n      properties: {},\n      geometry: {}\n    };\n    let el = this.querySelector('map-properties');\n    if (!el) {\n      json.properties = null;\n    } else if (typeof options.propertyFunction === 'function') {\n      json.properties = options.propertyFunction(el);\n    } else if (el.querySelector('table')) {\n      // setting properties when table presented\n      let table = el.querySelector('table').cloneNode(true);\n      json.properties = M._table2properties(table);\n    } else {\n      // when no table present, strip any possible html tags to only get text\n      json.properties = {\n        prop0: el.innerHTML.replace(/(<([^>]+)>)/gi, '').replace(/\\s/g, '')\n      };\n    }\n\n    // transform to gcrs if options.transform = true (default)\n    let source = null,\n      dest = null;\n    if (options.transform) {\n      source = new proj4.Proj(this._map.options.crs.code);\n      dest = new proj4.Proj('EPSG:4326');\n      if (\n        this._map.options.crs.code === 'EPSG:3857' ||\n        this._map.options.crs.code === 'EPSG:4326'\n      ) {\n        options.transform = false;\n      }\n    }\n\n    let collection = this.querySelector('map-geometry').querySelector(\n        'map-geometrycollection'\n      ),\n      shapes = this.querySelector('map-geometry').querySelectorAll(\n        'map-point, map-polygon, map-linestring, map-multipoint, map-multipolygon, map-multilinestring'\n      );\n\n    if (collection) {\n      json.geometry.type = 'GeometryCollection';\n      json.geometry.geometries = [];\n      for (let shape of shapes) {\n        json.geometry.geometries.push(\n          M._geometry2geojson(shape, source, dest, options.transform)\n        );\n      }\n    } else {\n      json.geometry = M._geometry2geojson(\n        shapes[0],\n        source,\n        dest,\n        options.transform\n      );\n    }\n    return json;\n  }\n\n  // a method that simulates a click, or invoking the user-defined click event\n  click() {\n    let g = this._groupEl,\n      rect = g.getBoundingClientRect();\n    let event = new MouseEvent('click', {\n      clientX: rect.x + rect.width / 2,\n      clientY: rect.y + rect.height / 2,\n      button: 0\n    });\n    let properties = this.querySelector('map-properties');\n    if (g.getAttribute('role') === 'link') {\n      for (let path of g.children) {\n        path.mousedown.call(this._featureGroup, event);\n        path.mouseup.call(this._featureGroup, event);\n      }\n    }\n    // dispatch click event for map-feature to allow events entered by 'addEventListener'\n    let clickEv = new PointerEvent('click', { cancelable: true });\n    clickEv.originalEvent = event;\n    this.dispatchEvent(clickEv);\n    // for custom projection, layer- element may disconnect and re-attach to the map after the click\n    // so check whether map-feature element is still connected before any further operations\n    if (properties && this.isConnected) {\n      let featureGroup = this._featureGroup,\n        shapes = featureGroup._layers;\n      // close popup if the popup is currently open\n      for (let id in shapes) {\n        if (shapes[id].isPopupOpen()) {\n          shapes[id].closePopup();\n        }\n      }\n      if (featureGroup.isPopupOpen()) {\n        featureGroup.closePopup();\n      } else if (!clickEv.originalEvent.cancelBubble) {\n        // If stopPropagation is not set on originalEvent by user\n        featureGroup.openPopup();\n      }\n    }\n  }\n\n  // a method that sets the current focus to the <g> element, or invoking the user-defined focus event\n  //      options (optional): as options parameter for native HTMLElement\n  //                          https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus\n  focus(options) {\n    this._groupEl.focus(options);\n  }\n\n  // a method that makes the <g> element lose focus, or invoking the user-defined blur event\n  blur() {\n    if (\n      document.activeElement.shadowRoot?.activeElement === this._groupEl ||\n      document.activeElement.shadowRoot?.activeElement.parentNode ===\n        this._groupEl\n    ) {\n      this._groupEl.blur();\n      // set focus to the map container\n      this._map._container.focus();\n    }\n  }\n\n  // a method that can the viewport to be centred on the feature's extent\n  zoomTo() {\n    let extent = this.extent,\n      map = this._map;\n    let tL = extent.topLeft.pcrs,\n      bR = extent.bottomRight.pcrs,\n      bound = L.bounds(\n        L.point(tL.horizontal, tL.vertical),\n        L.point(bR.horizontal, bR.vertical)\n      ),\n      center = map.options.crs.unproject(bound.getCenter(true));\n    map.setView(center, this.getMaxZoom(), { animate: false });\n  }\n  whenReady() {\n    return this._parentEl.whenReady().then(() => {\n      return new Promise((resolve, reject) => {\n        let interval, failureTimer;\n        if (this._featureGroup) {\n          resolve();\n        } else {\n          let featureElement = this;\n          interval = setInterval(testForFeature, 200, featureElement);\n          failureTimer = setTimeout(featureNotDefined, 5000);\n        }\n        function testForFeature(featureElement) {\n          if (featureElement._featureGroup) {\n            clearInterval(interval);\n            clearTimeout(failureTimer);\n            resolve();\n          }\n        }\n        function featureNotDefined() {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('Timeout reached waiting for feature to be ready');\n        }\n      });\n    });\n  }\n}\n"],"names":["MapFeature","HTMLElement","observedAttributes","zoom","this","hasAttribute","getAttribute","val","parsedVal","parseInt","isNaN","min","max","setAttribute","_layer","_layerEl","extent","minZoom","maxZoom","isConnected","_getFeatureExtent","_memoizeExtent","attributeChangedCallback","name","oldValue","newValue","let","layer","mapmlvectors","_mapmlvectors","_staticFeature","_removeInFeatureList","_features","push","_featureGroup","native","_getNativeZoomAndCS","_content","zoomBounds","M","getZoomBounds","constructor","super","connectedCallback","parentNode","nodeType","document","DOCUMENT_FRAGMENT_NODE","nodeName","toLowerCase","host","_addFeature","_observer","MutationObserver","mutation","mutationList","type","target","_reRender","observe","childList","subtree","attributes","attributeOldValue","characterData","disconnectedCallback","_removeFeature","disconnect","_groupEl","placeholder","createElement","insertAdjacentElement","_map","removeLayer","addData","cs","addTo","replaceWith","options","group","_setLayerElExtent","_setUpEvents","remove","shadowRoot","properties","_layers","_leaflet_id","_parentEl","toUpperCase","whenReady","then","parentLayer","parentElement","querySelector","_extentEl","checked","layerBounds","getBounds","_addZoomLimit","_resetFeatures","L","extend","Object","keys","length","forEach","addEventListener","clickEv","PointerEvent","cancelable","originalEvent","e","dispatchEvent","keyEv","KeyboardEvent","focusEv","FocusEvent","content","nativeZoom","nativeCS","metaZoom","metaCS","_metaContentToObject","Array","prototype","filter","call","elem","matches","getZoom","_nativeZoom","_nativeCS","Node","DOCUMENT_NODE","getNativeVariables","zoomMeta","querySelectorAll","zoomLength","split","find","str","includes","csMeta","csLength","extentCache","map","geometry","queryMetas","shapes","bboxExtent","Infinity","Number","NEGATIVE_INFINITY","shape","coord","i","data","innerHTML","trim","replace","tagName","_updateExtent","topLeft","point","bottomRight","pcrsBound","boundsToPCRSBounds","bounds","projection","resolutions","tileCenter","crs","tile","getCenter","pixel","transformation","transform","scale","pixelToPCRSBounds","subtract","add","result","assign","_convertAndFormatPCRS","splice","getMaxZoom","tL","pcrs","bR","bound","horizontal","vertical","layerZoomBounds","newZoom","mapml2geojson","propertyFunction","json","el","table","cloneNode","_table2properties","prop0","source","dest","proj4","Proj","code","collection","geometries","_geometry2geojson","click","g","rect","getBoundingClientRect","event","MouseEvent","clientX","x","width","clientY","y","height","button","path","children","mousedown","mouseup","featureGroup","id","isPopupOpen","closePopup","cancelBubble","openPopup","focus","blur","activeElement","_container","zoomTo","center","unproject","setView","animate","Promise","resolve","reject","interval","failureTimer","setInterval","featureElement","clearInterval","clearTimeout","setTimeout"],"mappings":"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"}