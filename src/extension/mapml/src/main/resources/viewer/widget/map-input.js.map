{"version":3,"file":"map-input.js","sources":["../src/map-input.js"],"sourcesContent":["/* global M */\nexport class MapInput extends HTMLElement {\n  static get observedAttributes() {\n    return [\n      'name',\n      'type',\n      'value',\n      'axis',\n      'units',\n      'position',\n      'rel',\n      'min',\n      'max',\n      'step'\n    ];\n  }\n  // sets default values for min,max on zoom and location input\n  // this stuff should be handled by the default getters on map-input type=location or map-input type=zoom\n  //          if (\n  //            inp.hasAttribute('type') &&\n  //            inp.getAttribute('type') === 'location' &&\n  //            (!inp.hasAttribute('min') || !inp.hasAttribute('max')) &&\n  //            inp.hasAttribute('axis') &&\n  //            !['i', 'j'].includes(inp.getAttribute('axis').toLowerCase())\n  //          ) {\n  //            if (\n  //              zoomInput &&\n  //              template.includes(`{${zoomInput.getAttribute('name')}}`)\n  //            ) {\n  //              zoomInput.setAttribute('value', boundsFallback.zoom);\n  //            }\n  //            let axis = inp.getAttribute('axis'),\n  //              axisBounds = M.convertPCRSBounds(\n  //                boundsFallback.bounds,\n  //                boundsFallback.zoom,\n  //                projection,\n  //                M.axisToCS(axis)\n  //              );\n  //            inp.setAttribute('min', axisBounds.min[M.axisToXY(axis)]);\n  //            inp.setAttribute('max', axisBounds.max[M.axisToXY(axis)]);\n  //          }\n\n  get name() {\n    return this.getAttribute('name');\n  }\n  set name(val) {\n    if (val) {\n      this.setAttribute('name', val);\n    }\n  }\n  get type() {\n    return this.getAttribute('type');\n  }\n  set type(val) {\n    if (['location'].includes(val)) {\n      this.setAttribute('type', val);\n    }\n  }\n  get value() {\n    return this.input.getValue();\n  }\n  set value(val) {\n    if (val) {\n      this.setAttribute('value', val);\n    }\n  }\n  get axis() {\n    return this.getAttribute('axis');\n  }\n  set axis(val) {\n    if (val) {\n      this.setAttribute('axis', val);\n    }\n  }\n  get units() {\n    return this.getAttribute('units');\n  }\n  set units(val) {\n    if (val) {\n      this.setAttribute('units', val);\n    }\n  }\n  get position() {\n    return this.getAttribute('position');\n  }\n  set position(val) {\n    if (val) {\n      this.setAttribute('position', val);\n    }\n  }\n  get rel() {\n    return this.getAttribute('rel');\n  }\n  set rel(val) {\n    if (val) {\n      this.setAttribute('rel', val);\n    }\n  }\n  get min() {\n    switch (this.type) {\n      case 'zoom':\n        if (this.hasAttribute('min')) {\n          return this.getAttribute('min');\n          // min attribute can apply to: type=location, type=zoom\n          // for zoom, it should fall back via upward document search: 1) this element,\n          // 2) map-meta within the parent extent, 3) map-meta within the parent layer,\n          // or finally 4) the map projection crs min/min\n          // for location, it should fall back by searching upwards: same as for zoom\n        } else if (this.parentElement.querySelector('map-meta[name=zoom]')) {\n          // fallback map-meta on layer\n          return M._metaContentToObject(\n            this.parentElement\n              .querySelector('map-meta[name=zoom]')\n              .getAttribute('content')\n          ).min;\n        } else {\n          // fallback map min\n          return this.getLayerEl().extent?.zoom.minZoom.toString();\n        }\n        break;\n      case 'location':\n      default:\n        break;\n    }\n  }\n  set min(val) {\n    if (val) {\n      this.setAttribute('min', val);\n    }\n  }\n  get max() {\n    switch (this.type) {\n      case 'zoom':\n        if (this.hasAttribute('max')) {\n          return this.getAttribute('max');\n          // max attribute can apply to: type=location, type=zoom\n          // for zoom, it should fall back via upward document search: 1) this element,\n          // 2) map-meta within the parent extent, 3) map-meta within the parent layer,\n          // or finally 4) the map projection crs min/max\n          // for location, it should fall back by searching upwards: same as for zoom\n        } else if (this.parentElement.querySelector('map-meta[name=zoom]')) {\n          // fallback map-meta on layer\n          return M._metaContentToObject(\n            this.parentElement\n              .querySelector('map-meta[name=zoom]')\n              .getAttribute('content')\n          ).max;\n        } else {\n          // fallback map max\n          return this.getLayerEl().extent?.zoom.maxZoom.toString();\n        }\n        break;\n      case 'location':\n      default:\n        break;\n    }\n  }\n  set max(val) {\n    if (val) {\n      this.setAttribute('max', val);\n    }\n  }\n  get step() {\n    if (this.type !== 'zoom') {\n      return null;\n    } else {\n      return this.getAttribute('step') || '1';\n    }\n  }\n  set step(val) {\n    if (val) {\n      this.setAttribute('step', val);\n    }\n  }\n  getLayerEl() {\n    return this.getRootNode() instanceof ShadowRoot\n      ? this.getRootNode().host\n      : this.closest('layer-');\n  }\n  attributeChangedCallback(name, oldValue, newValue) {\n    this.whenReady()\n      .then(() => {\n        switch (name) {\n          case 'name':\n            if (oldValue !== newValue) {\n              // update associated class value on attribute change\n              if (oldValue !== null) {\n                this.input.name = newValue;\n              }\n            }\n            break;\n          case 'type':\n            if (oldValue !== newValue) {\n              // handle side effects\n              // not allowed to change 'type'\n            }\n            break;\n          case 'value':\n            if (oldValue !== newValue) {\n              if (oldValue !== null) {\n                this.input.value = newValue;\n              }\n            }\n            break;\n          case 'axis':\n            if (oldValue !== newValue && this.input) {\n              // handle side effects\n              this.input.axis = newValue;\n            }\n            break;\n          case 'units':\n            if (oldValue !== newValue && this.input) {\n              // handle side effects\n              this.input.units = newValue;\n            }\n            break;\n          case 'position':\n            if (oldValue !== newValue && this.input) {\n              // handle side effects\n              this.input.position = newValue;\n            }\n            break;\n          case 'rel':\n            if (oldValue !== newValue && this.input) {\n              // handle side effects\n              this.input.rel = newValue;\n            }\n            break;\n          case 'min':\n            if (oldValue !== newValue && this.input) {\n              // handle side effects\n              this.input.min = newValue;\n            }\n            break;\n          case 'max':\n            if (oldValue !== newValue && this.input) {\n              // handle side effects\n              this.input.max = newValue;\n            }\n            break;\n          case 'step':\n            if (oldValue !== newValue && this.input) {\n              // handle side effects\n              this.input.step = newValue;\n            }\n            break;\n        }\n      })\n      .catch((reason) => {\n        console.log(\n          reason,\n          `\\nin mapInput.attributeChangeCallback when changing attribute ${name}`\n        );\n      });\n  }\n  constructor() {\n    // Always call super first in constructor\n    super();\n  }\n  connectedCallback() {\n    this.parentElement\n      .whenReady()\n      .then(() => {\n        if (this.parentElement.nodeName === 'MAP-EXTENT') {\n          this._layer = this.parentElement._layer;\n        }\n        switch (this.type) {\n          case 'zoom':\n            // input will store the input Class specific to the input type\n            this.initialValue = +this.getAttribute('value');\n            this.input = new M.ZoomInput(\n              this.name,\n              this.min,\n              this.max,\n              this.initialValue,\n              this.step,\n              this._layer\n            );\n            break;\n          case 'location':\n            // input will store the input Class specific to the input type\n            this.input = new M.LocationInput(\n              this.name,\n              this.position,\n              this.axis,\n              this.units,\n              this.min,\n              this.max,\n              this.rel,\n              this._layer\n            );\n            break;\n          case 'width':\n            // input will store the input Class specific to the input type\n            this.input = new M.WidthInput(this.name, this._layer);\n            break;\n          case 'height':\n            // input will store the input Class specific to the input type\n            this.input = new M.HeightInput(this.name, this._layer);\n            break;\n          case 'hidden':\n            // input will store the input Class specific to the input type\n            this.input = new M.HiddenInput(this.name, this.initialValue);\n            break;\n        }\n      })\n      .catch((reason) => {\n        console.log(reason, '\\nin mapInput.connectedCallback');\n      });\n  }\n  disconnectedCallback() {}\n\n  //https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/checkValidity\n  checkValidity() {\n    if (this.input.validateInput()) {\n      return true;\n    } else {\n      const evt = new Event('invalid', {\n        bubbles: true,\n        cancelable: true,\n        composed: true\n      });\n      this.dispatchEvent(evt);\n      return false;\n    }\n  }\n\n  //https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement/reportValidity\n  reportValidity() {\n    if (this.input.validateInput()) {\n      return true;\n    } else {\n      const evt = new Event('invalid', {\n        bubbles: true,\n        cancelable: true,\n        composed: true\n      });\n      this.dispatchEvent(evt);\n      //if the event isn't canceled reports the problem to the user.\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#dom-cva-reportvalidity-dev\n      console.log(\"Input type='\" + this.type + \"' is not valid!\");\n      return false;\n    }\n  }\n  whenReady() {\n    return new Promise((resolve, reject) => {\n      let interval, failureTimer;\n      if (this.input) {\n        resolve();\n      } else {\n        let inputElement = this;\n        interval = setInterval(testForInput, 300, inputElement);\n        failureTimer = setTimeout(inputNotDefined, 10000);\n      }\n      function testForInput(inputElement) {\n        if (inputElement.input) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          resolve();\n        } else if (!inputElement.isConnected) {\n          clearInterval(interval);\n          clearTimeout(failureTimer);\n          reject('map-input was disconnected while waiting to be ready');\n        }\n      }\n      function inputNotDefined() {\n        clearInterval(interval);\n        clearTimeout(failureTimer);\n        reject('Timeout reached waiting for input to be ready');\n      }\n    });\n  }\n}\n"],"names":["MapInput","HTMLElement","observedAttributes","name","this","getAttribute","val","setAttribute","type","includes","value","input","getValue","axis","units","position","rel","min","hasAttribute","parentElement","querySelector","M","_metaContentToObject","getLayerEl","extent","zoom","minZoom","toString","max","maxZoom","step","getRootNode","ShadowRoot","host","closest","attributeChangedCallback","oldValue","newValue","whenReady","then","catch","console","log","reason","constructor","super","connectedCallback","nodeName","_layer","initialValue","ZoomInput","LocationInput","WidthInput","HeightInput","HiddenInput","disconnectedCallback","checkValidity","validateInput","evt","Event","bubbles","cancelable","composed","dispatchEvent","reportValidity","Promise","resolve","reject","let","interval","failureTimer","setInterval","inputElement","clearInterval","clearTimeout","isConnected","setTimeout"],"mappings":"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"}